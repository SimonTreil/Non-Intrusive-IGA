#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
from numpy import linalg
import scipy.sparse as sp
import scipy.sparse.linalg as splalg
import sys
sys.path.insert( 0, '/home/larousse/Bureau/INSA/5A/Projet/Git/Non-Intrusive-IGA/CasTests/PoutreCourbe')
import reac_noda as rn
import libaster as la

### GLOBAL.MED
## GROUP OF EDGES : 
## Wd, Fd, Auxi
## GROUP OF FACES :
## DiriG, ForG, AuxiG

## DEBUT CODE ASTER
DEBUT(PAR_LOT='NON',IMPR_MACRO = 'NON')


########################################################################################################
## INITIALISATION : KG, KL, conditions de Dirichlet, FG, FL..
########################################################################################################

KG, vciG, vneG, MatG, modG, numDDLG  = la.Global()
KL, vneL, matL, modL,numDDLL  = la.Local()

########################################################################################################
## PREMIERE ITERATION
########################################################################################################
########################################################################################################
# Global : KG*UG=FG
########################################################################################################

UG = RESOUDRE(MATR=matAssG, CHAM_NO=vneumG, CHAM_CINE=vcineG,)
   
########################################################################################################
# Local : KL*UL=FL avec Dirichlet déplacement
########################################################################################################

# On crée UG sous forme de résultat
UGR = CREA_RESU(OPERATION = 'AFFE',
		        TYPE_RESU = 'EVOL_ELAS',
		        NOM_CHAM = 'DEPL',
		        AFFE = _F(CHAM_GD = UG,
		                INST = 1.
		                )
		        )
	
# On projette ce résultat sur la frontière (Diri) => on a un evol	     
UIMP=PROJ_CHAMP(RESULTAT=UGR, MODELE_1=modG,MODELE_2=modL,METHODE='COLLOCATION',
                VIS_A_VIS=_F(GROUP_MA_1='AuxiG',GROUP_MA_2='Diri', CAS_FIGURE='2D'))

# On impose ce evol en condition de Dirichlet cinématique
UGL=AFFE_CHAR_CINE(MODELE=modL, EVOL_IMPO=UIMP,)
vciL= CALC_CHAR_CINE(NUME_DDL=numDDLL, CHAR_CINE=UGL,);

# On assemble une nouvelle matrice de rigidité 
matAssL2 = ASSE_MATRICE(MATR_ELEM=matElemL, NUME_DDL=numDDLL,CHAR_CINE=UGL)
matAssL2 = FACTORISER(reuse=matAssL2,MATR_ASSE=matAssL2, METHODE='MUMPS');

# On résoud avec ces nouvelles conditions
UL = RESOUDRE(MATR=matAssL2, CHAM_NO=vneL,CHAM_CINE=vciL,)
# Cependant attention, on a pas fait avec dualisation lagrangienne donc UL != [UL, Lambda] 
# mais c'est censé passer avec le compute_nodal_reaction etc

########################################################################################################
# Extraction de Lambda / réaction nodale
########################################################################################################

LAMBDA = la.compute_nodal_reaction_from_field_on_group(UL,modL,matL,'Diri',char_cine=UGL)

########################################################################################################
# Extraction de KA*UG
########################################################################################################
DETRUIRE(CONCEPT=_F(NOM=toto))
DETRUIRE(CONCEPT=_F(NOM=nodalrea))
KAUG = la.compute_nodal_reaction_from_field_on_group(UG,modG,MatG,'AuxiG',char_cine=FixG)

#KaugG = AFFE_CHAR_MECA(MODELE = modG,	
#		       CHAMNO_IMPO = _F(CHAM_NO = KAUG,
#		  	     		COEF_IMPO = 1.,)
#		    )

total = CREA_CHAMP(OPERATION='COMB',
		    TYPE_CHAM='NOEU_DEPL_R',
		    COMB=(_F(CHAM_GD=KAUG,COEF_R=1.),
		    	  _F(CHAM_GD=LAMBDA,COEF_R=-1.),
		    	  _F(CHAM_GD=vneumG,COEF_R=1.),)
		   )
		
totalG = AFFE_CHAR_MECA(MODELE = modG,	
		        CHAMNO_IMPO = _F(CHAM_NO = total,
		  	     		COEF_IMPO = 1.,)
		        )
DETRUIRE(CONCEPT=_F(NOM=toto))
DETRUIRE(CONCEPT=_F(NOM=nodalrea))
#matElmG2 = CALC_MATR_ELEM(OPTION='RIGI_MECA', MODELE=modG, CHAM_MATER=MatG,CHARGE=KaugG)

#numDDLG2 = NUME_DDL(MATR_RIGI=matElmG2, );


#matAssG2 = ASSE_MATRICE(MATR_ELEM=matElmG2, NUME_DDL=numDDLG2, CHAR_CINE=FixG)

#vcineG2 = CALC_CHAR_CINE(NUME_DDL=numDDLG, CHAR_CINE=FixG,);

# Calcul du second membre lié aux CL de Neumann
#vecElmG2 = CALC_VECT_ELEM(OPTION='CHAR_MECA',CHARGE=totalG,CHAM_MATER=MatG)
#vneumG2 = ASSE_VECTEUR(VECT_ELEM=vecElmG2,NUME_DDL=numDDLG)

########################################################################################################
# Convergence (facultatif)
########################################################################################################
## .....



########################################################################################################
# BOUCLE POUR ITERATIONS = 2 .. 30
########################################################################################################

########################################################################################################
# A FAIRE : REUTILISER CONCEPTS DANS LA BOUCLE (DETRUIRE ou astuce de Oumaziz)
########################################################################################################



for ifp in range(1,30):             
    print('iter #'+str(ifp))
    ####################################################################################################
    # Résolution global
    ####################################################################################################
    DETRUIRE(CONCEPT=_F(NOM=UG))
    UG = RESOUDRE(MATR=KG, CHAM_NO=total, CHAM_CINE=vciG,)
    
    ####################################################################################################
    # Extraction -CG*UG
    ####################################################################################################
    DETRUIRE(CONCEPT=_F(NOM=UGR))
    # On crée UG sous forme de résultat
    UGR = CREA_RESU(OPERATION = 'AFFE',
		    TYPE_RESU = 'EVOL_ELAS',
		    NOM_CHAM = 'DEPL',
		    AFFE = _F(CHAM_GD = UG,
		              INST = 1.
		             )
		    )
    DETRUIRE(CONCEPT=_F(NOM=UIMP))
    # On projette ce résultat sur la frontière (Diri) => on a un evol	     
    UIMP=PROJ_CHAMP(RESULTAT=UGR, MODELE_1=modG,MODELE_2=modL,METHODE='COLLOCATION',
                    VIS_A_VIS=_F(GROUP_MA_1='AuxiG',GROUP_MA_2='Diri', CAS_FIGURE='2D'))
    DETRUIRE(CONCEPT=_F(NOM=UGL))
    DETRUIRE(CONCEPT=_F(NOM=vciL))
    # On impose ce evol en condition de Dirichlet cinématique
    UGL=AFFE_CHAR_CINE(MODELE=modL, EVOL_IMPO=UIMP,)
    vciL= CALC_CHAR_CINE(NUME_DDL=numDDLL, CHAR_CINE=UGL,);

    ####################################################################################################
    # Résolution local avec déplacement imposé
    ####################################################################################################
    DETRUIRE(CONCEPT=_F(NOM=matAssL2))
    # On assemble une nouvelle matrice de rigidité 
    matAssL2 = ASSE_MATRICE(MATR_ELEM=matElemL, NUME_DDL=numDDLL,CHAR_CINE=UGL)
    matAssL2 = FACTORISER(reuse=matAssL2,MATR_ASSE=matAssL2, METHODE='MUMPS');
    DETRUIRE(CONCEPT=_F(NOM=UL))
    # On résoud avec ces nouvelles conditions
    UL = RESOUDRE(MATR=matAssL2, CHAM_NO=vneL,CHAM_CINE=vciL,)
    
    ####################################################################################################
    # Extraction réaction nodale
    ####################################################################################################
    DETRUIRE(CONCEPT=_F(NOM=LAMBDA))
    LAMBDA = la.compute_nodal_reaction_from_field_on_group(UL,modL,matL,'Diri',char_cine=UGL)

    ####################################################################################################
    # Extraction KA*UG
    ####################################################################################################
    DETRUIRE(CONCEPT=_F(NOM=toto))
    DETRUIRE(CONCEPT=_F(NOM=nodalrea))
    DETRUIRE(CONCEPT=_F(NOM=KAUG))
    DETRUIRE(CONCEPT=_F(NOM=total))
    
    KAUG = la.compute_nodal_reaction_from_field_on_group(UG,modG,MatG,'AuxiG',char_cine=None)

    print("on est à KAUG")
    resu = CREA_RESU(OPERATION = 'AFFE',
                     TYPE_RESU = 'EVOL_ELAS',
                     NOM_CHAM = 'DEPL',
                     AFFE = _F(CHAM_GD = UG,
                               MODELE = modG,
                              CHAM_MATER = MatG,
                               INST = 0.,)
                     )
    IMPR_RESU(FORMAT = 'MED',UNITE=84,RESU=_F(RESULTAT=resu))
    print("pb avec Calc champ ?")
    resu= CALC_CHAMP(reuse = resu,
                     FORCE = 'REAC_NODA',
                     #TOUT='OUI',
                     GROUP_MA = 'Auxi', # SUR JUSTE FD OU WD => REAC_NODA pas possible
                     RESULTAT = resu,
                     INST=0.)
#    print("pb avec crea champ ?")
    KAUG = CREA_CHAMP(OPERATION = 'EXTR',
                                NOM_CHAM = 'REAC_NODA',
                                TYPE_CHAM = 'NOEU_DEPL_R',
                                RESULTAT = resu,
                                INST=0.
                                )    
  
    
    total = CREA_CHAMP(OPERATION='COMB',
	    	        TYPE_CHAM='NOEU_DEPL_R',
		        COMB=(_F(CHAM_GD=KAUG,COEF_R=1.),
		              _F(CHAM_GD=LAMBDA,COEF_R=-1.),
		    	      _F(CHAM_GD=vneumG,COEF_R=1.),)
		       )
    DETRUIRE(CONCEPT=_F(NOM=toto))
    DETRUIRE(CONCEPT=_F(NOM=nodalrea))
    ####################################################################################################
    # Calcul de convergence
    ####################################################################################################
    # ....
    
########################################################################################################
# RESULTATS
########################################################################################################    
    
# Création du concept de résultat
ResG = CREA_RESU(OPERATION = 'AFFE',
		 TYPE_RESU = 'EVOL_ELAS',
		 NOM_CHAM = 'DEPL',
		 AFFE = _F(CHAM_GD = UG,
		           MODELE = modG,
		           CHAM_MATER = MatG,
		           INST = 1.
		           )
		)

# Calcul des champs de réactions nodales
ResG = CALC_CHAMP(reuse = ResG,
	         RESULTAT = ResG,
	         FORCE = 'REAC_NODA',
	         TOUT = 'OUI',
	         )
		         
# Sauvegarde au format med
IMPR_RESU(FORMAT = 'MED',UNITE=80,RESU=_F(RESULTAT=ResG))
   
# Création du concept de résultat
ResL = CREA_RESU(OPERATION = 'AFFE',
		 TYPE_RESU = 'EVOL_ELAS',
		 NOM_CHAM = 'DEPL',
		 AFFE = _F(CHAM_GD = UL,
		           MODELE = modL,
		           CHAM_MATER = matL,
		           INST = 1.
		           )
		)

# Calcul des champs de réactions nodales
ResL = CALC_CHAMP(reuse = ResL,
	         RESULTAT = ResL,
	         FORCE = 'REAC_NODA',
	         TOUT = 'OUI',
	         )
		         
# Sauvegarde au format med
IMPR_RESU(FORMAT = 'MED',UNITE=83,RESU=_F(RESULTAT=ResL))







    
    #LAM = RESOUDRE(MATR=KL,)
    #Ka = la.compute_nodal_reaction_from_field_on_group(UG,G,mat) 
    #FGG = FG -LAMB + Ka
    #vecElem = CALC_VECT_ELEM(OPTION='CHAR_MECA',CHARGE=Fd,CHAM_MATER=Mat)
    
    #vneum = ASSE_VECTEUR(VECT_ELEM=vecElem,NUME_DDL=numDDL)

    #sol = RESOUDRE(MATR=KG, CHAM_NO=vneum, CHAM_CINE=vcine,)
    ### GLOBAL
    #FGG = FG #- ...
    #UG=KGLU.solve(FGG)
    #FG=F - CG.T.dot(LAM) + KG.dot(UGold)
    #UG[rep]=IGALU.solve(FG[rep])

       # err=np.r_[err,np.linalg.norm(UG-UGold)/np.linalg.norm(UG)]

    ### LOCAL
    #FL=np.zeros(mf.ndof+ndof_interf)
    #FL[mf.ndof:]=-CG.dot(UG)
    #UL=EFLU.solve(FL)
    #LAM=UL[mf.ndof:]
    #print(np.linalg.norm(UL[:mf.ndof]))
    #mf.VTKSol('marie_loc',UL[:mf.ndof])
    #UGold=UG.copy()
